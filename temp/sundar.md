---
layout: page
title: "Project Panama and jextract"
permalink: /sundar/
redirect_from:
  - /temp_sundar/

---

The goal of [Project Panama](https://openjdk.java.net/projects/panama/) is to enrich the connections between the Java virtual machine and well-defined but 'foreign', i.e. non-Java APIs. 


At a high level, there are 2 things to deal with when accessing native APIs from Java, i.e. accessing the foreign memory, and invoking the foreign code.

Until now, there were different approaches to access native memory from Java. For example, one can use [ByteBuffer.allocateDirect](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/nio/ByteBuffer.html#allocateDirect(int)). One of the problem with this approach is that the native memory allocated via `allocateDirect` is only freed when the ByteBuffer is garbage collected! Another 'solution' us to rely on undocumented and unsupported Unsafe classes but this is britlle and not recommended! 

To invoke native code (ex. C, C++, etc.) from Java, [Java Native Interface (JNI)](https://docs.oracle.com/en/java/javase/15/docs/specs/jni/index.html) has always been the de-facto solution but JNI is cumbersome (**list other drawbacks???**).




Panama solves those issues by introducing a supported, efficient, and secure way to invoke native code from Java.
Panama has 2 fundametal APIs, the [Foreign-Memory Access API](https://openjdk.java.net/jeps/383), currently incubating in JDK 15, and the [Foreign Linker API](https://openjdk.java.net/jeps/389) (candidate JEP). This post discusses 2 aspects of Panama: the Foreign Linker API but also the jextract tool.

<center>~</center>

## JNI AKA the "old way"

Let's first look at the current situation with JNI. The following example illustrates how to call the `getpid` C function from Java.

### 1. Write the Java class

```java
class Main {
  public static void main(String[] args) {
    System.out.println("my process id: " + getpid());
  }

  private static native int getpid();
}
```
### 2. Compile the class, and generate the corresponding header file
```sh
$ javac -h . Main.java
```

The `-h` flag instruct _javac_ to generate a C header file along with the compiled class. This generated header file (_Main.h_) looks as follow.

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class Main */

#ifndef _Included_Main
#define _Included_Main
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     Main
 * Method:    getpid
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_Main_getpid
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```

### 3. Implement the C function

_Main.c_

```c
#include <unistd.h>
#include "Main.h"

JNIEXPORT jint JNICALL Java_Main_getpid
  (JNIEnv *env, jclass cls) {
  // call the actual C function to get the process id!
  return getpid();
}
```

### 4. Compile the C code into a dynamic library so that JVM can load it

```sh
# Note: JAVA_HOME is the directory where your JDK is installed
# Following is Mac OS command to compile it into a dynamic library
# This step is OS and compiler dependent!

$ cc -shared -o libmain.dylib -I $JAVA_HOME/include -I $JAVA_HOME/include/darwin Main.c
```

### 5. Load the dynamic library from within the Java program


```java
class Main {
  public static void main(String[] args) {
    System.loadLibrary("main"); // <--- load dynamic library
    System.out.println("my process id: " + getpid());
  }

  private static native int getpid();
}
```

### 6. Run the program

```sh
$ java Main.java 
my process id: 86733
```


This basic example shows what is necessary to invoke, using JNI, a native function from Java.
In a nutshell, we had to
1. Declare native method(s) in your Java class
2. Compile your Java class with `-h` flag to generate a C header
3. Implement the generated C declaration
4. Compile a dynamically loaded library
5. Load this dynamic library using [`System.loadLibrary`](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/System.html#loadLibrary(java.lang.String))


So we had to implement an intermediate native code wrapper to call original native function! In other words, we had to write and compile and native code to be able (!) to call an existing native library! That is, at best, cumbersome!



<center>~</center>
# Enters Panama Foreign Linker API

This example is using Panama's Foreign Linker API to invoke the same native function.


```java
import java.lang.invoke.*;
import jdk.incubator.foreign.*;

class PanamaMain {
  public static void main(String[] args) throws Throwable {
    // get System linker
    var linker = CLinker.getInstance();
    var lookup = LibraryLookup.ofDefault();

    // get a native method handle for 'getpid' function
    var getpid = linker.downcallHandle(
           lookup.lookup("getpid").get(),
           MethodType.methodType(int.class),
           FunctionDescriptor.of(CLinker.C_INT));

    // invoke it!
    System.out.println((int)getpid.invokeExact());
  }
}
```

The following command is used to compile and run this Java program.

```sh
$ java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign  PanamaMain.java
WARNING: Using incubator modules: jdk.incubator.foreign
WARNING: using incubating module(s): jdk.incubator.foreign
1 warning
87543
```


ðŸ’¡ `-Dforeign.restricted=permit` is required to permit native method handles from Java

ðŸ’¡ `--add-modules` is required as Panama APIs are still incubating

ðŸ’¡ This example uses [JEP 330](https://openjdk.java.net/jeps/330) to compile and run the class in a single step


As we can see, Panama's Foreign Linker API is straight forward as it doesn't require to write (and compile!) intermediate native wrapper like JNI does! To try this example, simply install the latest [Panama Early Access build](https://jdk.java.net/panama/).


<center>~</center>

# Enters Panama _jextract_

In the previous example, we managed to invoke `getpid` from Java without writing any native code wrapper. But we have to deal with [method handle](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/invoke/MethodHandle.html), FunctionDescriptor, method handle type, C symbol name, ... just to call a simple C API. 

This is where **jextract** comes in! It is a tool that extracts Java interface(s) from C header file(s).

Let's do the same `getpid` example using **jextract**.

```c
// simple header file that contains C declaration
// you can extract arbitrary C header file btw.
int getpid();
```

The following command extracts a Java interface for the above C header, this interface will use the `com.unix` package.

```sh
$ jextract -t com.unix getpid.h
WARNING: Using incubator modules: jdk.incubator.foreign, jdk.incubator.jextract
```

Now let's use `com.unix.* `from a new Main class (_Main2.java_).

```java
import static com.unix.getpid_h.*;

class Main2 {
   public static void main(String[] args) {
      System.out.println(getpid());
  }
}
```
No method handle lookup, no invokeExact, etc. It couldn't be more simple! 

The following command will run the example.

```sh
$ java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign  Main2.java
WARNING: Using incubator modules: jdk.incubator.foreign
warning: using incubating module(s): jdk.incubator.foreign
1 warning
87716
```


`getpid` is a one basic example, more interesting examples combining **jextract** with the technologies bellow can be found [here](https://github.com/sundararajana/panama-jextract-samples).
* Python
* SQLite
* OpenGL
* TensorFlow
* LAPACK
* BLAS
* libgit2

<center>~</center>

### Conclusions

This post uses 2 approaches to invoke from Java the native `getpid` function, using the old JNI approach, and using the new **Panama Foreign Linker API**. We can see that the Foreign Linker API is simple and straight forward as it does not require to deal with an intermediate native code wrapper. Moreover, **jextract** is a Panama tool that can simplify things further as it parses headers to generate the corresponding native bindings. 


